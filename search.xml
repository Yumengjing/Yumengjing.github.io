<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[.NetCore的入门认识和创建]]></title>
    <url>%2F2019%2F03%2F26%2FNetCore%E7%9A%84%E5%85%A5%E9%97%A8%E8%AE%A4%E8%AF%86%2F</url>
    <content type="text"><![CDATA[1.什么是 dotnet Core .NET Core是适用于 windows、linux 和 macos 操作系统的免费、开源托管的计算机软件框架，是微软开发的第一个官方版本，具有跨平台 (Windows、Mac OSX、Linux) 能力的应用程序开发框架 (Application Framework)，未来也将会支持 FreeBSD 与 Alpine 平台，也是微软在一开始发展时就开源的软件平台，它经常也会拿来和现有的开源 .NET 平台 Mono 比较。 由于 .NET Core 的开发目标是跨平台的 .NET 平台，因此 .NET Core 会包含 .NET Framework 的类库，但与 .NET Framework 不同的是 .NET Core 采用包化 (Packages) 的管理方式，应用程序只需要获取需要的组件即可，与 .NET Framework 大包式安装的作法截然不同，同时各包亦有独立的版本线 (Version line)，不再硬性要求应用程序跟随主线版本。 .NET Core 项目的主要目标有：支持或可以移转 (port) 到更多的操作系统平台与芯片架构 (也就是未来项目会跨出 x86 平台)。具有引人注目的性能与高可靠度。开发人员能快速与直接的获取 .NET Core 开发环境。在直觉与具生产力的情况下建造应用程序，使用文件，示例与 NuGet 组件。 -》官方的教程：ASP.NET Core 入门中文教程（点击跳转） 可过浏览官方文档更加详细说明。 2.NetCore 环境部署 环境部署下载专门 .NET Core 2.2 SDK 目前.Net Core 的版本有 1.0 2.0 2.2 3.0 版本号，可以根据个人需要下载，以下是Net Core 2.2 SDK环境下载地址，点击获取。 .NET Core 2.2 SDK 下载地址 命令dotnet 判断是否安装车成功 1dotnet --help 安装成功会提示显示以下内容,通过下面的文本能里了解到常用的sdk-options、SDK命令、捆绑工具中的其他命令: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556.NET 命令行工具 (2.1.503)使用情况: dotnet [runtime-options] [path-to-application] [arguments]执行 .NET Core 应用程序。runtime-options: --additionalprobingpath &lt;path&gt; 要探测的包含探测策略和程序集的路径。 --additional-deps &lt;path&gt; 指向其他 deps.json 文件的路径。 --fx-version &lt;version&gt; 要用于运行应用程序的安装版共享框架的版本。 --roll-forward-on-no-candidate-fx 已启用“不前滚到候选共享框架”。path-to-application: 要执行的应用程序 .dll 文件的路径。使用情况: dotnet [sdk-options] [command] [command-options] [arguments]执行 .NET Core SDK 命令。sdk-options: -d|--diagnostics 启用诊断输出。 -h|--help 显示命令行帮助。 --info 显示 .NET Core 信息。 --list-runtimes 显示安装的运行时。 --list-sdks 显示安装的 SDK。 --version 显示使用中的 .NET Core SDK 版本。SDK 命令: add 将包或引用添加到 .NET 项目。 build 生成 .NET 项目。 build-server 与由生成版本启动的服务器进行交互。 clean 清理 .NET 项目的生成输出。 help 显示命令行帮助。 list 列出 .NET 项目的项目引用。 migrate 将 project.json 项目迁移到 MSBuild 项目。 msbuild 运行 Microsoft 生成引擎(MSBuild)命令。 new 创建新的 .NET 项目或文件。 nuget 提供其他 NuGet 命令。 pack 创建 NuGet 包。 publish 发布 .NET 项目进行部署。 remove 从 .NET 项目中删除包或引用。 restore 还原 .NET 项目中指定的依赖项。 run 生成并运行 .NET 项目输出。 sln 修改 Visual Studio 解决方案文件。 store 在运行时包存储中存储指定的程序集。 test 使用 .NET 项目中指定的测试运行程序运行单元测试。 tool 安装或管理扩展 .NET 体验的工具。 vstest 运行 Microsoft 测试引擎(VSTest)命令。捆绑工具中的其他命令: dev-certs 创建和管理开发证书。 ef Entity Framework Core 命令行工具。 sql-cache SQL Server 缓存命令行工具。 user-secrets 管理开发用户密码。 watch 启动文件观察程序，它会在文件发生更改时运行命令。运行 &quot;dotnet [command] --help&quot;，获取有关命令的详细信息。 通过上面内容，我们可以尝试了解一下 new 指令的作用可以执行一下语句 1dotnet new --help 便可大致了解dotnet new –help 或者 dotnet new –h 作用 1234567891011121314151617181920212223242526272829303132333435选项: -h, --help 显示有关此命令的帮助。 -l, --list 列出包含指定名称的模板。如果未指定名称，请列出所有模板。 -n, --name 正在创建输出的名称。如果未指定任何名称，将使用当前目录的名称。 -o, --output 要放置生成的输出的位置。 -i, --install 安装源或模板包。 -u, --uninstall 卸载一个源或模板包。 --nuget-source 指定在安装期间要使用的 NuGet 源。 --type 基于可用的类型筛选模板。预定义的值为 &quot;project&quot;、&quot;item&quot; 或 &quot;other&quot;。 --force 强制生成内容，即使该内容会更改现有文件。 -lang, --language 根据语言筛选模板，并指定要创建的模板的语言。模板 短名称 语言 标记----------------------------------------------------------------------------------------------------------------------Console Application console [C#], F#, VB Common/ConsoleClass library classlib [C#], F#, VB Common/LibraryUnit Test Project mstest [C#], F#, VB Test/MSTestNUnit 3 Test Project nunit [C#], F#, VB Test/NUnitNUnit 3 Test Item nunit-test [C#], F#, VB Test/NUnitxUnit Test Project xunit [C#], F#, VB Test/xUnitRazor Page page [C#] Web/ASP.NETMVC ViewImports viewimports [C#] Web/ASP.NETMVC ViewStart viewstart [C#] Web/ASP.NETASP.NET Core Empty web [C#], F# Web/EmptyASP.NET Core Web App (Model-View-Controller) mvc [C#], F# Web/MVCASP.NET Core Web App razor [C#] Web/MVC/Razor PagesASP.NET Core with Angular angular [C#] Web/MVC/SPAASP.NET Core with React.js react [C#] Web/MVC/SPAASP.NET Core with React.js and Redux reactredux [C#] Web/MVC/SPARazor Class Library razorclasslib [C#] Web/Razor/Library/Razor Class LibraryASP.NET Core Web API webapi [C#], F# Web/WebAPIglobal.json file globaljson ConfigNuGet Config nugetconfig ConfigWeb Config webconfig ConfigSolution File sln Solution 3.用命令行创建第一个net Core 项目程序 win+R 打开cmd命令台 可通过命令行创建项目文件名称 或者 创建文件夹，文件夹内按住Shift+鼠标右键 1mkdir hellocore //创建文件夹语句 跳转文件夹内 1cd hellocore //跳转到hellocare的文件夹内 创建mvc模板的core 123dotnet new mvc //创建.netCore MVC模式的项目 如想新建其他类型的项目，可通过dotnet new --help 命令查看//常用的项目类型还有 Web WebApi Razor 等 文章上面提及，具体详情可上上文 运行 12dotnet run (一般http://localhost:5000 下运行)//可通过打开浏览器输入http://localhost:5000 便可查看结果 发布程序 12dotnet publish otnet publish -o D:\dotnet\Web_IIS\hellocoreWeb （发布到指定位置）]]></content>
      <categories>
        <category>.Net Core</category>
      </categories>
      <tags>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVP——最小可行化产品]]></title>
    <url>%2F2018%2F10%2F29%2F%E6%9C%80%E5%B0%8F%E5%8F%AF%E8%A1%8C%E5%8C%96%E4%BA%A7%E5%93%81MVP%2F</url>
    <content type="text"><![CDATA[最简可行产品+测试产品：概念最简可行产品（minimum viable product，简称MVP）是新产品开发中的名词，是指有部分机能，恰好可以让设计者表达其核心设计概念的产品。设计者可以进行验证式学习，根据使用者的回馈，进一步了解使用情形，并且继续开发此产品 。由最简可行产品来搜集相关想法常常会比开发有更多机能的产品要便宜。开发更多机能产品的的费用较高，也会有产品失败的风险（例如产品基本假设有误的情形）。最简可行产品一词是由法兰克·罗宾生（Frank Robinson）创建，因史蒂夫·布兰克及埃里克·莱斯的使用而流行。 “要贩售愿景及提供最简可行产品给有远见的人，不是给所有的人。”——史蒂夫·布兰克MVP具有以下三个特点： 是一种避免开发出客户并不真正需要的产品的开发策略。 快速地构建出符合产品预期功能的最小功能集合，通过迭代来完善。 是让开发团队用最小的代价实现一个产品，以此最大程度上了解和验证对用户问题的解决程度。 设计技巧 定位一致，满足核心需求 体现核心竞争力/亮点只做核心功能（人无我有，人有我精）快速试验亮点功能并获得第一批用户例：支付宝初期核心功能为支付和担保交易 成本尽可能低使用“轮子”，尽可能套用现有方案以快速实现 示例假设客户需要一辆汽车，我们应该使用什么样的流程完成骑车的开发呢？ 传统软件开发流程中如上半部分图片的流程，我们会慢慢的将汽车的每一个部件按顺序制造出来，最终得到整个骑车。 MVP最小可行化产品设计流程中，我们应该意识到，客户需要一辆汽车的本质其实是需要一个出行工具，应该用最小的可以满足客户需求的方式实现用户出行的需求，然后再不断对工具进行迭代，最终得到一辆汽车。 图示如下： 最小可行化，即，不断获取可行化与最小化交集： 注意事项 避免粗糙造成印象分扣减（注重MVP的体验，而不只是功能） 避免切分范围太小达不到验证效果（需要完整的表达出需求） 保持与主要定位一致避免影响核心理念（体现出正确的价值） 总结 以用户问题为中心，而不是以解决方案为中心。 首先着眼于基本的客户需求，通过客户反馈，逐步修正产品设计和实现。 在各个迭代过程中，做出来的产品始终是可为客户所用的产品。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>产品</tag>
        <tag>MVP</tag>
        <tag>最小可行化</tag>
        <tag>最简可行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Orale查询优化改》读后笔记]]></title>
    <url>%2F2018%2F10%2F10%2F%E3%80%8AOrale%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E6%94%B9%E5%86%99%E3%80%8B%E8%AF%BB%E5%90%8E%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[第一章单表查询：1.3 查找空值 和 null对于不同的函数起不同作用12replace('strng','a','b') --在string查找a,然后用b替换greatest('a','b') --返回最大值，其中字符串和数值比较各有不同，当数和字符串比较会提示错误 1.4 将空值转换为实际值123coalesce 和 nvl ，获取第一个不为空的值，其中coalesce支持多个参数，比nvl更好coalesce('','','','') --同时多个参数nvl(nvl('',''),'') --多层嵌套，每次只能比较两个数值 1.7.为列名取有意义的名称123select A as B from table; select A B from table; 上述两个意思一样，将A列名改为B 1.8 在where 子句中引用取别名的列,需要嵌套一层select1select * from (select A as B from table) where B = "b" 1.9 拼接列 || 双竖杆为拼接符号12345678910select A||'的父亲是'||B as C from table；结果：C---------------------A的父亲是B用来拼接SQL,用于直接用基础数据或者数据字典来批量生产，进行修改select ‘truncate table ’ || ' owner ' || '.' || table_name || ';' as 清空表from all_tables where owner = 'scott';--将会对用户为scott拥有的表进行删除操作 1.11 限制返回的行数 rownum1select * from tanle where rownum &lt;= 2 ; 最多返回两行 1.12 从表中随机返回n条记录 dbms_random.value 获取随机数12345select * from (select A from table order by dbms_random.value )where rownum &lt;= 3 ;注意：先随机排序、再取返回行数错误写法如下：先取数据再随机排序 select A from table where rownum &lt;= 3 order by dbms_random.value ; 1.13 模糊查询1234567通配符：%(替代一个或多个字符) _ (替代一个或多个字符)常用方法：%%select * from table where A like '%a%';转义字符 \select * from table where A like '%\_%' esacpe '\';转义\ 为 \\ 双斜杆 代表一个 \ 且作为通配符处理select * from table where A like '%\\_%' esacpe '\'; 第二章：给查询结果排序2.1指定的次序返回查询额几个123select A,B,C from table order by A asc; asc 按照小到大排序 desc 按照大到小排序select A,B,C from table order by 1 asc; 排序结果以第一列【排序注意：数据替代列位置，只能用于order by 2.3 按字符排序12select A,B,C,substr(A,-4) as 尾号 from table where rownum &lt;= 5 order by 4 asc; 通过截取出来的第四列尾号进行排序 2.4 translate 是replace的超集1234语法：translate(expr , from_string , to_string)from_string 和 to_string 以字符串为单位，对应字符一一替换1、to_string 为空，返回空值2、to_string 对应的位置没有字符，删除from_string 中列出来的字符将会被消掉。！！ 2.5 按数字和字母混合字符串中的字母排序(数字排序) 使用translate 函数过滤不需要字符12345678910select A|| ' ' || B as date from table ; //其中A 是数据 B 是字母查询结果为1234 kell123 cat现在排序查询：select date , translate(date,'- 0123456789','-') as date2 from table order by date2 ;把数字和空格转为空，利用2.4的第二点内容 2.6 处理排序空值1234用 nvl(A, -1 ) 这种方式为空值赋值，需要对列的类型和保存数据有所了解，如果保存数据变化是，该语句需要维护，不太友好关键字 nulls first 空值在前 和 null last 空值在后select A,B,C from table order by 3 nulls first ;select A,B,C from table order by 3 nulls last; 2.7根据条件取不同的列中的值来排序处理12345678910通过新生一列，用多排序方式处理select A,B,case where A &gt;=0 and A &lt; 5 then a else 2 end as C,D from tablewhere D = '销售部'order by 3,4 ;不显示多一行，将case where 放到order by 后面select A,B,D from tablewhere D = '销售部'order by case where A &gt;=0 and A &lt; 5 then a else 2 end ,3 ; 第三章：操作多张表3.1 union all 与空字符串1234select A,B,C from table union allselect A,B,&apos;&apos; as C from table_a其中第二个 ‘’ as c 相当于 NULL空字符串 3.2 union 与 or1234//创建索引create index idx_empno on emp(empo)create index idx_ename on emp(ename)union 和 union all 其中union 去掉重复数据 3.4 in exists 和 inner join123456inner join 没有重复列时候可以直接使用select * from table where A in ('','')select * from table where (A,B) in (select A,B from table2) select A,B,C from table a where exists(select A,B,C from table2 b where a.A= b.A )select A,B,C from table inner join table2 on (a.A = b.A)select A from table a,table2 b where a.A= b.A 3.5 inner join 内关联 、left join 左关联 、right join 右关联 和 full join 外关联(全关联)3.6 自关联3.7 not in 、 not exists 和 left join3.8 外连接的条件不能乱放，否则就内部运行，不按照对应的方式查询3.9 检测两个表中的数据及对应数据的条数相同 例子p453.10 聚集与内连接 p463.11 聚集与外连接 p503.12 从多个表中返回丢失的数据 p501通过full jin 和 union all 方式显示，关联缺少数据 3.13 多表查询时的空值处理12注意：与空值比较之后的值依旧为空值，需要转化之后才能比较 coalesce(a.comn,0) 如果为空则为0 第四章 插入更新与修改4.1 插入新纪录 p55123456789create table table_a(a varchar2(10) default '默认值a',b varchar2(10) default '默认值b',c varchar2(10) default '默认值c',d data default sysdate,e decimal default 0);default 默认值insert into table_a (a,b,c) values ('a',null,'c'); 4.2 阻止对某列的插入 p561创建一个view然后插入值，不过不能再使用default的默认属性了 4.3 复制表的定义及数据 p571234a.复制表的定义及数据create table table_b as select * from table_a;b.复制标的定义不包括数据,然后再自己新增数据create table table_b as select * from table_a wherer 1=2; 4.4 用 with check option 限制数据的录入 p57123456789a.简单的直接添加到表结构内下 constraints 添加约束条件ps: alter table_a add constraints ch_e check (e &gt; 0); a必须大于0 才能插入b.复杂或特殊的约束条件是不能直接放到表内的如日期等ps: alter table_a add contraints ch_d checck ( d &gt;= sysdate );错误提示：ora-02436:日期或者系统变量在check 约束条件中指定错误c.with check option 使用insert into table_a (select a,b,c,d from table_a where d &lt;= sysdate with check option ) values ('a','b','c',sysdate+1);错误提示：ora-01402 视图with check option where 子句违规 4.5 多表插入语句 p5812345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970四种情况：a. 无条件 insertb. 有条件 insert allc. 转置 insertd. 有条件 insert first a. 无条件的insert 创建两个测试表 create or replace table_b as select a,b,c from table_a where 1=2 create or replace table_c as select a,b,e from table_a where 1=2 insert all into table_b (a,b,c) values (a,b,c) into table_c (a,b,e) values (a,b,e) select a,b,c,e from table_a where a in ('a_1','a_2') 没有条件，所以table_b和table_c的条数一样b.有条件的insert all delete table_b; delect table_c; 清空表table_b,table_c的数据 insert all when c in ('c_1','c-2') then into table_b (a,b,c) values (a,b,c) when e &gt; 20 then into table_c (a,b,e) values (a,b,e) select a,b,c,e from table_a where a in ('a_1','a_2')d. 有条件的 insert frist insert first when c in ('c_1','c-2') then into table_b (a,b,c) values (a,b,c) when e &gt; 20 then into table_c (a,b,e) values (a,b,e) select a,b,c,e from table_a where a in ('a_1','a_2') 当符合第一个条件之后插入table_b，即使满足第二个条件也不会插入table_c内，这是和 insert all 和 insert first 区别所在e. 转置 insert (以其一个分类，不然说是insert all 的一个用法) 将不同列的数据插入到同一张表的不同行内 drop table t1; drop table t2; create table t2 (d varchar2(10), des varchar2(50)); create table t1 as select '熊1,精神不佳' as d1, '熊2,精神不佳' as d2, '熊3,精神不佳' as d3, '熊4,精神不佳' as d4, '熊5,精神不佳' as d5 from dual; /*转置*/ insert all into t2(d,des) values ('周1',d1) into t2(d,des) values ('周2',d2) into t2(d,des) values ('周3',d3) into t2(d,des) values ('周4',d4) into t2(d,des) values ('周5',d5) select d1,d2,d3,d4,d5 form t1; /*结果*/ select * from t2 ----------------------------------------------- 周1 熊1，精神不佳 周2 熊2，精神不佳 周3 熊3，精神不佳 周4 熊4，精神不佳 周5 熊5，精神不佳 等价于sql语句 insert t2 (d,des) select '周1',d1 from t1 union all select '周2',d2 from t1 union all select '周3',d3 from t1 union all select '周4',d4 from t1 union all select '周5',d5 from t1 ; 4.6 用其他表中的值更新 p6312345678910alter table_a add aname varchar2(50) default 'noname'; 添加上限制，否则全部更新，不符合更新条件的数据将会被设值为NULL 添加where exists() 获取需要更新的语句alter table_a add contraints pk_a primary key (a) ; //添加主键 方式三种：直接关联、view 、merge(只关联一个数据库)merge into emp using( select dname,deptno from dept where depy.name in ('a','b') ) dept on (dept.deptno = emp.deptno ) when matched then update set emp.dname = dept.dname; 4.7 合并记录 p67 *** merge into 重点方式和详细使用，可同时操作增删改进行12345678merge into table_a a using (select a,b from table_b where a = 'good') b on (b,a = a.a) when matchtd then //满足条件 update set a.a= a.a + b.b; delect where () when not matched then //不满足条件的 insert (a.a) values (b.b) where b.c &lt; =800 ; 4.8 删除违反参照完整性的记录 p71123alter table table_a add contraints pk_a primary key (a) //主键alter table table_b add contraints fk_b_a foreign key (a) references table_a(a) //外检create index idx_a,b on table_a(a,b) //索引 4.9 删除名称重复的记录 p72123451.通过字段判断（建立索引加快效率） create index idx_a,b on table_a(a,b) //索引2.通过rowid判断3.通过分组序号判断 row_number() over (partition by name order by id) as sep 通过名称，ID排序获取行号 第五章、使用字符串5.1 遍历字符串1234567891011select level form dual connect by level &lt;= 4 connect by 是一种树形查询的一个子句返回的值是伪列，表示树形中的级别层次例子：create or replace view v as select "天天向上" as 汉字,'TTXS' as 拼音 from dual;select v.拼音,v.汉字,level,substr(v.汉字,level,1) as 拆分汉字,substr(v.拼音,level,1) as 拆分拼音from v connect by level &lt;= length(v.汉字); 5.2 字符串文字包含引号123456789101112131415161718oracle 10g 新增了 q_quote 特性 定界符 q'[132]' 界定符可以是‘’,[],()&lt;&gt; ，而且必须成对存在开头是Q或者q，后面加定位符,中间放内容 5.3 计算字符在字符串中出现的次数1.计算子字符串个数，分隔符字符串是一个 a. oracle 11g 提供函数 regexp_count 计算出现次数 select regexp_count(str,',') + 1 from dual; select regexp_count('qwe,qeqew,qeqe',',') + 1 from dual; //获取字符串个数 b. 没有regexp_count 函数则用regexp_replace 迂回求值即可 select length(regexp_replace(str,'[^,]')) + 1 from dual; select length(regexp_replace('字,符,串','[^,]')) + 1 from dual; //返回三 c. 还可以使用translate() select length(translate(str,','||str,',') +1 from dual; select length(translate('字,符,串',','||'字,符,串',',')) +1 from dual;2.分隔符号是多个时候,如分隔字符为‘S#’ //需要考虑分隔符长度问题 select length(translate(str,'S#' || str ,'S#')) / length('S#') +1 as cnt from dual; select regexp_count(str,'S#') + 1 from dual; //regexp_count 不需要考虑长度问题 5.4 从字符串中删除不需要的字符串12345例子：将名字中的元音字符 aeiou 去掉1. select replace(translate(str,'aeiou','aaaaa'),'a','') from dual; 将元音转换为a之后在替换为‘’2. select translate(str,'1aeiou','1') from dual;3.正则表达式替换 regexp_replace,相当于执行多个replace方式 select regexp_replace(str,'[aeiou]') from dual; 5.5 将字符和数字数据分隔 regexp_replace123456使用正则表达式 ^否意思 如果不放在方括号内且开头，如 ^hell 默认字符串开始位置 select regexp_replace(str,'[0-9]','') , regexp_replace(str,'[^0-9]','') from dual ;ps：select regexp_replace('1asd123','[0-9]','') ,regexp_replace('1asd123','[^0-9]','') from dual ; 结果 asd 1123下面translate 达到相同的效果ps: select translate('1asd123','a0123456789','a') as 非数字, translate('1asd123','0123456789'||'1asd123' ,'0123456789') as 数字 from dual; 5.6 查询只包含字母或数字型的数据1234567891011正则表达式一些小知识regexp_count 统计数量 regexp_replace 替换 regexp_like 模糊查询[^] ^ 代表否定 ^str 代表字符串的开始位置 regexp_like(str,'a') like ''%a% regexp_like(str,'^a') like 'a%' 没有前模糊查询 regexp_like(str,'a$') like '%a' 没有后模糊查询 regexp_like(str,’^a$') like 'a' 精确查询 + 和 * ‘+’ 表示匹配前面的表达式一次或多次：‘*’ 表示匹配前面的表达式零或多次regexp_like(str,'16+') like '16%'regexp_like(str,'16*') like '1%'注意：NULL 是不能用like来比较的 5.7 提取姓名的大写首字母缩写123456789正则表达式实现 select regexp_replace(str,'([[:upper:]])(.*)([[:upper:]])(.*)','\1.\3') from dual; select regexp_replace('Hello World','([[:upper:]])(.*)([[:upper:]])(.*)','\1.\3') from dual; select regexp_replace('Hello World Gong','([[:upper:]])(.*)([[:upper:]])(.*)([[:upper:]])(.*)','\1.\3.\5') from dual;()()()()将字符串分隔四部分，\1.\3 分别取13部分，中间加‘.’符号translate 方式替换更加简洁 select translate(str,' '|| lower(str),'.') from dual; select translate('Hello World Gong',' '|| lower('Hello World Gong'),'.') from dual;先将字符串转小写，然后空格替换为’.‘ 结果保留大写字母 5.8 按字符串中的数值排序123456可以通过正则表达式和translate 方式新增一列清空非数字列，排序 select str,to_number(regexp_replace(str,'[^0-9]','') ) as str2 from dual order by str2; select str,to_number(translate(str,'0123456789'|| str,'0123456789') ) as str2 from dual order by str2;ps:例子 select 'asdfasdf12',to_number(regexp_replace('asdfasdf12','[^0-9]','') ) as str2 from dual order by str2; select 'asdfasdf12',to_number(translate( 'asdfasdf12','0123456789'|| 'asdfasdf12','0123456789') ) as str2 from dual order by str2; 5.9 根据表中的行创建一个分隔列表1234wmsys.wm_concat 函数 具有不确定性 返回varcahr,但是在oracl 11.2 返回的是clob类型oracl 11.2 开始有分析函数 listagg select deptno,sun(sal) as total_sal, listagg(ename,',') with group (order by ename ) as tomal_name from emp order by deptno; 5.10 提取第N个分隔字符串123正则表达式 regexp_substr select regexp_substr(str,'[^,]+',1,2) as 子字符串 from dual; select regexp_substr('aa,b,ac,ad,','[^,]+',1,4) as 子字符串 from dual; //最后一个参数是返回第四个字符串 5.11 分隔ip地址12345678910select regexp_substr(str,'[^.]+',1,1) as ip1, regexp_substr(str,'[^.]+',1,2) as ip2, regexp_substr(str,'[^.]+',1,3) as ip3, regexp_substr(str,'[^.]+',1,4) as ip4 from dual;select regexp_substr('192.168.1.1','[^.]+',1,1) as ip1, regexp_substr('192.168.1.1','[^.]+',1,2) as ip2, regexp_substr('192.168.1.1','[^.]+',1,3) as ip3, regexp_substr('192.168.1.1','[^.]+',1,4) as ip4 from dual; 5.12 将分隔数据转换为多值in列表123regexp_substr 和 translate 结合 转换为 in 条件入参 select * from emp where ename in ( select regexp_substr(str, '[^,]+', 1, level) as ename from dual connect by level &lt;= (length(translate(str,',' || str ,',')) + 1)); select * from emp where ename in ( select regexp_substr(str, '[^,]+', 1, level) as ename from dual connect by level &lt;= (regexp_count(str,',') + 1)); 5.13 按照字母顺序排序字符串123456789通过拆分字符串+ listagg 合并显示结果1.拆分 select str,substr(str,level,1) from dual connect by level &lt;= lenght(str) ; ps: select 'fdavs',substr( 'fdavs',level,1) from dual connect by level &lt;= length( 'fdavs') ;2.listagg 合并 select str,listagg(substr(str,level,1)) within group(order by substr(str,level,1) ) as str2 from dual connect by level &lt;= length(str) order by str2; ps : select 'fdavs',listagg(substr('fdavs',level,1)) within group(order by substr('fdavs',level,1) ) as str2 from dual connect by level &lt;= length('fdavs') order by str2;3去重复 select listagg(MIN(substr('fdaaavs',level,1))) within group(order by MIN(substr('fdaaavs',level,1))) as str2 from dual connect by level &lt;= length('fdaaavs') group by (substr('fdaaavs',level,1)) 5.14 判别可作为数值的字符串123rpad 填充 select substr('AAA-BBB',1,instr('AAA-BBB','-',-1)-1) 值 from dual; 结果 AAA select substr('AAA-BBB',instr('AAA-BBB','-',-1)+1) 值 from dual; 结果 BBB]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F05%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
</search>
